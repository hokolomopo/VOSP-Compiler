import java_cup.runtime.*;
import tokens.Token;
import lexer.VSOPLexer;
import java_cup.runtime.ComplexSymbolFactory.Location;
import AST.*;
import exceptions.ParserError;
import java.util.List;

parser code {:
    // Connect this parser to a scanner!
    Scanner s;
    ComplexSymbolFactory sf;
    ASTNode abstractTree;

    public void init(Scanner s, ComplexSymbolFactory sf){ this.s=s; this.sf = sf;}

    public ASTNode getTree(){return abstractTree;}

    public void report_error(String message, Object info) {
        if (info instanceof ComplexSymbolFactory.ComplexSymbol) {

          ComplexSymbolFactory.ComplexSymbol s = (ComplexSymbolFactory.ComplexSymbol)info;

          //Return previous token if current has no indication of location. Should only happens on EOF.
          if(s.xleft == null || s.xright == null){
              s = ((VSOPScanner)this.s).getPrev();
          }
          List expected = expected_token_ids();

          throw new ParserError(s, expected, s.xleft.getLine(), s.xleft.getColumn());

          //throw new ParserError(s.xleft.getLine(), s.xleft.getColumn());
        }
    }


:}

/* define how to connect to the scanner! */
init with {: :};
scan with {: return s.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal Token      AND, BOOL, CLASS, DO, ELSE, EXTENDS, FALSE, IF, IN, INT32, ISNULL, LET, NEW, NOT, STRING, THEN, TRUE, UNIT, WHILE;
terminal Token      LBRACE, RBRACE, LPAR, RPAR, COLON, SEMICOLON, COMMA, PLUS, MINUS, TIMES, DIV, POW, DOT, EQUAL, LOWER, LOWER_EQUAL, ASSIGN;
terminal Token      STRING_LITERAL, IDENTIFIER, TYPE_IDENTIFIER, INT_LITERAL;
terminal            UMINUS;

/* Non terminals */
non terminal ClassList                program;
non terminal ClassList                classList;
non terminal ClassItem                classItem;
non terminal ClassElementList         classBody, classElementList;
non terminal FormalList               formalList, formals;
non terminal Field                    field;
non terminal Method                   method;
non terminal Type                     type;
non terminal Formal                   formal;
non terminal ExprList                 block, exprList;
non terminal Expr                     expr, matched, unmatched, simpleExpr, literal, booleanLiteral;
non terminal ArgList                  args, argList;
non terminal empty;

/* Precedences */
precedence right    ASSIGN;
precedence left     AND;
precedence right    NOT;
precedence nonassoc LOWER, LOWER_EQUAL, EQUAL;
precedence left     PLUS, MINUS;
precedence left     TIMES, DIV;
precedence right    ISNULL, UMINUS;
precedence right    POW;
precedence left     DOT;

start with program;

/* The grammar rules */
program ::=
  classList:cl    {: abstractTree = cl; :}
;

classList ::= 
  classList:cl classItem:ci   {: RESULT = new ClassList(cl, ci); :}
| empty                       {: RESULT = new ClassList(); :}
;

classItem ::= 
  CLASS TYPE_IDENTIFIER:ti classBody:cel                                      {: RESULT = new ClassItem(ti.getValue(), cel); :}
| CLASS TYPE_IDENTIFIER:ti EXTENDS TYPE_IDENTIFIER:ti_parent classBody:cel    {: RESULT = new ClassItem(ti.getValue(), ti_parent.getValue(), cel); :}
;

classBody ::= 
  LBRACE classElementList:cel RBRACE    {: RESULT = cel; :}
;

classElementList ::= 
  classElementList:cel field:f    {: RESULT = new ClassElementList(cel, f); :}
| classElementList:cel method:m   {: RESULT = new ClassElementList(cel, m); :}
| empty                           {: RESULT = new ClassElementList(); :}
;

field ::=
  IDENTIFIER:id COLON type:ty SEMICOLON                   {: RESULT = new Field(id.getValue(), ty); :}
| IDENTIFIER:id COLON type:ty ASSIGN expr:val SEMICOLON   {: RESULT = new Field(id.getValue(), ty, val); :}
;

method ::=
  IDENTIFIER:id LPAR formals:fo RPAR COLON type:ty block:b    {: RESULT = new Method(id.getValue(), fo, ty, b); :}
;

type ::=
  TYPE_IDENTIFIER:ti      {: RESULT = new Type(ti.getValue()); :}
|  INT32                  {: RESULT = new Type("int32"); :}
|  BOOL                   {: RESULT = new Type("bool"); :}
|  STRING                 {: RESULT = new Type("string"); :}
|  UNIT                   {: RESULT = new Type("unit"); :}
;

formals ::=
  formalList:fl formal:f           {: RESULT = new FormalList(fl, f); :}
| empty                            {: RESULT = new FormalList(); :}
;

formalList ::=
  formalList:fl formal:f COMMA     {: RESULT = new FormalList(fl, f); :}
| empty                            {: RESULT = new FormalList(); :}
;

formal ::=
  IDENTIFIER:id COLON type:ty      {: RESULT = new Formal(id.getValue(), ty); :}
;

block ::=
  LBRACE exprList:el expr:e RBRACE           {: RESULT = new ExprList(el, e); :}
;

exprList ::=
  exprList:el expr:e SEMICOLON         {: RESULT = new ExprList(el, e); :}
| empty                                {: RESULT = new ExprList(); :}
;

expr ::=
  matched:m       {: RESULT = m; :}
| unmatched:u     {: RESULT = u; :}
;

matched ::=
  IF expr:e1 THEN matched:e2 ELSE matched:e3                          {: RESULT = new If(e1, e2, e3); :}
| simpleExpr:n                                                        {: RESULT = n; :}
| WHILE matched:e1 DO matched:e2                                      {: RESULT = new While(e1, e2); :}
| LET IDENTIFIER:id COLON type:ty IN matched:e                        {: RESULT = new Let(id.getValue(), ty, e); :}
| LET IDENTIFIER:id COLON type:ty ASSIGN matched:e1 IN matched:e2     {: RESULT = new Let(id.getValue(), ty, e1, e2); :}
| IDENTIFIER:id ASSIGN matched:e                                      {: RESULT = new Assign(id.getValue(), e); :}
| NOT:kw matched:e                                                    {: RESULT = new UnOp(kw.getTokenType().getStringValue(), e); :}
| MINUS:kw matched:e                                                  {: RESULT = new UnOp(kw.getTokenType().getStringValue(), e); :} %prec UMINUS
| ISNULL:kw matched:e                                                 {: RESULT = new UnOp(kw.getTokenType().getStringValue(), e); :}
| matched:e1 AND:kw matched:e2                                        {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| matched:e1 EQUAL:kw matched:e2                                      {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| matched:e1 LOWER:kw matched:e2                                      {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| matched:e1 LOWER_EQUAL:kw matched:e2                                {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| matched:e1 PLUS:kw matched:e2                                       {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| matched:e1 MINUS:kw matched:e2                                      {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| matched:e1 TIMES:kw matched:e2                                      {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| matched:e1 DIV:kw matched:e2                                        {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| matched:e1 POW:kw matched:e2                                        {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| matched:e DOT IDENTIFIER:id LPAR args:ar RPAR                       {: RESULT = new Call(e, id.getValue(), ar); :}
;

unmatched ::=
  IF expr:e1 THEN expr:e2                                                 {: RESULT = new If(e1, e2); :}
| IF expr:e1 THEN matched:e2 ELSE unmatched:e3                            {: RESULT = new If(e1, e2, e3); :}
| WHILE unmatched:e1 DO unmatched:e2                                      {: RESULT = new While(e1, e2); :}
| LET IDENTIFIER:id COLON type:ty IN unmatched:e                          {: RESULT = new Let(id.getValue(), ty, e); :}
| LET IDENTIFIER:id COLON type:ty ASSIGN unmatched:e1 IN unmatched:e2     {: RESULT = new Let(id.getValue(), ty, e1, e2); :}
| IDENTIFIER:id ASSIGN unmatched:e                                        {: RESULT = new Assign(id.getValue(), e); :}
| NOT:kw unmatched:e                                                      {: RESULT = new UnOp(kw.getTokenType().getStringValue(), e); :}
| MINUS:kw unmatched:e                                                    {: RESULT = new UnOp(kw.getTokenType().getStringValue(), e); :}
| ISNULL:kw unmatched:e                                                   {: RESULT = new UnOp(kw.getTokenType().getStringValue(), e); :}
| unmatched:e1 AND:kw unmatched:e2                                        {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| unmatched:e1 EQUAL:kw unmatched:e2                                      {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| unmatched:e1 LOWER:kw unmatched:e2                                      {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| unmatched:e1 LOWER_EQUAL:kw unmatched:e2                                {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| unmatched:e1 PLUS:kw unmatched:e2                                       {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| unmatched:e1 MINUS:kw unmatched:e2                                      {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| unmatched:e1 TIMES:kw unmatched:e2                                      {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| unmatched:e1 DIV:kw unmatched:e2                                        {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| unmatched:e1 POW:kw unmatched:e2                                        {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| unmatched:e DOT IDENTIFIER:id LPAR args:ar RPAR                         {: RESULT = new Call(e, id.getValue(), ar); :}
;

simpleExpr ::=  //TODO check if while etc
  IDENTIFIER:id LPAR args:ar RPAR                               {: RESULT = new Call(new Id("self"), id.getValue(), ar); :}
| NEW TYPE_IDENTIFIER:ti                                        {: RESULT = new New(ti.getValue()); :}
| IDENTIFIER:id                                                 {: RESULT = new Id(id.getValue()); :}
| literal:li                                                    {: RESULT = li; :}
| LPAR expr:e RPAR                                              {: RESULT = e; :}
| block:b                                                       {: RESULT = b; :}
;

args ::=
  argList:al expr:e      {: RESULT = new ArgList(al, e); :}
| empty                  {: RESULT = new ArgList(); :}
;

argList ::=
  argList:al expr:e COMMA       {: RESULT = new ArgList(al, e); :}
| empty                         {: RESULT = new ArgList(); :}
;

literal ::=
  INT_LITERAL:il         {: RESULT = new LiteralInteger(il.getValue()); :}
| STRING_LITERAL:sl      {: RESULT = new LiteralString(sl.getValue()); :}
| booleanLiteral:bl      {: RESULT = bl; :}
;

booleanLiteral ::=
  TRUE:bl       {: RESULT = new LiteralBoolean(bl.getTokenType().getStringValue()); :}
| FALSE:bl      {: RESULT = new LiteralBoolean(bl.getTokenType().getStringValue()); :}
;

empty ::= ;

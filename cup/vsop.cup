import java_cup.runtime.*;
import tokens.Token;
import lexer.VSOPLexer;
import java_cup.runtime.ComplexSymbolFactory.Location;

parser code {:
    // Connect this parser to a scanner!
    Scanner s;
    ComplexSymbolFactory sf;
    public void init(Scanner s, ComplexSymbolFactory sf){ this.s=s; this.sf = sf;}

:}

/* define how to connect to the scanner! */
init with {: :};
scan with {: return s.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            AND, BOOL, CLASS, DO, ELSE, EXTENDS, FALSE, IF, IN, INT32, ISNULL, LET, NEW, NOT, STRING, THEN, TRUE, UNIT, WHILE;
terminal            LBRACE, RBRACE, LPAR, RPAR, COLON, SEMICOLON, COMMA, PLUS, MINUS, TIMES, DIV, POW, DOT, EQUAL, LOWER, LOWER_EQUAL, ASSIGN;
terminal String     STRING_LITERAL, IDENTIFIER, TYPE_IDENTIFIER, INT_LITERAL;

/* Non terminals */
non terminal            classList, classItem, classBody, classElementList;
non terminal            field, method, type, formals, formal, block, expr, elseExpr, exprList, args, argList, literal, booleanLiteral;
non terminal empty;

/* Precedences */
precedence right    ASSIGN;
precedence left     AND;
precedence right    NOT;
precedence nonassoc LOWER, LOWER_EQUAL, EQUAL;
precedence left     PLUS, MINUS;
precedence left     TIMES, DIV;
precedence right    ISNULL, UNIT;
precedence right    POW;
precedence left     DOT;
precedence left ELSE;//TODO; ca regle un probleme avec if/then/else, mais est ce que ca le regele bien?

start with classList;  

/* The grammar rules */
classList ::= 
  classItem classList 
| empty
;

classItem ::= 
  CLASS TYPE_IDENTIFIER classBody     {: System.out.println("Simple class");:}
| CLASS TYPE_IDENTIFIER EXTENDS TYPE_IDENTIFIER classBody    {: System.out.println("Herited class");:}
;

classBody ::= 
  LBRACE classElementList RBRACE
;//TODO : Empty class OK?

classElementList ::= 
  field classElementList
| method classElementList
| empty
;

field ::=
  IDENTIFIER COLON type SEMICOLON
| IDENTIFIER COLON type ASSIGN expr SEMICOLON
;

method ::=
  IDENTIFIER LPAR formals RPAR COLON type block
;

type ::=
  TYPE_IDENTIFIER
|  INT32
|  BOOL
|  STRING
|  UNIT
;

formals ::=
  formal
| formal COMMA formals
| empty
;

formal ::=
  IDENTIFIER COLON type
;

block ::=
  LBRACE expr exprList RBRACE           {:System.out.println("Block");:}
;

exprList ::=
  SEMICOLON expr exprList
| empty
;

expr ::=
  IF expr THEN expr elseExpr
| WHILE expr DO expr
| LET IDENTIFIER COLON type IN expr
| LET IDENTIFIER COLON type ASSIGN expr IN expr
| IDENTIFIER ASSIGN expr
| NOT expr
| expr AND expr
| expr EQUAL expr
| expr LOWER expr
| expr LOWER_EQUAL expr
| expr PLUS expr
| expr MINUS expr
| expr TIMES expr
| expr DIV expr
| expr POW expr
| MINUS expr
| ISNULL expr
| IDENTIFIER LPAR args RPAR
| expr DOT IDENTIFIER LPAR args RPAR
| NEW TYPE_IDENTIFIER
| IDENTIFIER
| literal
| LPAR RPAR
| LPAR expr RPAR
| block
;

elseExpr ::=
  ELSE expr
| empty
;

args ::=
  expr argList
| empty
;

argList ::=
  COMMA expr
| empty
;

literal ::=
  INT_LITERAL
| STRING_LITERAL
| booleanLiteral
;

booleanLiteral ::=
  TRUE
| FALSE
;

empty ::= ;

import java_cup.runtime.*;
import tokens.Token;
import lexer.VSOPLexer;
import java_cup.runtime.ComplexSymbolFactory.Location;
import AST.*;

parser code {:
    // Connect this parser to a scanner!
    Scanner s;
    ComplexSymbolFactory sf;
    public void init(Scanner s, ComplexSymbolFactory sf){ this.s=s; this.sf = sf;}

:}

/* define how to connect to the scanner! */
init with {: :};
scan with {: return s.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            AND, BOOL, CLASS, DO, ELSE, EXTENDS, FALSE, IF, IN, INT32, ISNULL, LET, NEW, NOT, STRING, THEN, TRUE, UNIT, WHILE;
terminal            LBRACE, RBRACE, LPAR, RPAR, COLON, SEMICOLON, COMMA, PLUS, MINUS, TIMES, DIV, POW, DOT, EQUAL, LOWER, LOWER_EQUAL, ASSIGN;
terminal String     STRING_LITERAL, IDENTIFIER, TYPE_IDENTIFIER, INT_LITERAL;

/* Non terminals */
non terminal            program, classList, classItem, classBody, classElementList, formalList;
non terminal            field, method, type, formals, formal, block, expr, matched, unmatched, noIf, exprList, args, argList, literal, booleanLiteral;
non terminal empty;

/* Precedences */
precedence right    ASSIGN;
precedence left     AND;
precedence right    NOT;
precedence nonassoc LOWER, LOWER_EQUAL, EQUAL;
precedence left     PLUS, MINUS;
precedence left     TIMES, DIV;
precedence right    ISNULL, UNIT;
precedence right    POW;
precedence left     DOT;

start with program;

/* The grammar rules */
program ::=
  classList:cl    {: cl.print(); :}
;

classList ::= 
  classList:cl classItem:ci   {: RESULT = new ClassList(cl, ci); :}
| empty                       {: RESULT = new ClassList(); :}
;

classItem ::= 
  CLASS TYPE_IDENTIFIER:ti classBody:cel                                      {: RESULT = new ClassItem(ti.stringValue(), cel); :}
| CLASS TYPE_IDENTIFIER:ti EXTENDS TYPE_IDENTIFIER:ti_parent classBody:cel    {: RESULT = new ClassItem(ti.stringValue(), ti_parent.stringValue(), cel); :}
;

classBody ::= 
  LBRACE classElementList:cel RBRACE    {: RESULT = cel; :}
;

classElementList ::= 
  classElementList:cel field:f    {: RESULT = new ClassElementList(cel, f); :}
| classElementList:cel method:m   {: RESULT = new ClassElementList(cel, m); :}
| empty                           {: RESULT = new ClassElementList(); :}
;

field ::=
  IDENTIFIER:id COLON type:ty SEMICOLON                   {: RESULT = new Field(id.stringValue(), ty); :}
| IDENTIFIER:id COLON type:ty ASSIGN expr:val SEMICOLON   {: RESULT = new Field(id.stringValue(), ty, val); :}
;

method ::=
  IDENTIFIER:id LPAR formals:fo RPAR COLON type:ty block:b    {: RESULT = new Method(id.stringValue(), fo, ty, b); :}
;

type ::=
  TYPE_IDENTIFIER:ti      {: RESULT = new Type(ti.stringValue()); :}
|  INT32                  {: RESULT = new Type("int32"); :}
|  BOOL                   {: RESULT = new Type("bool"); :}
|  STRING                 {: RESULT = new Type("string"); :}
|  UNIT                   {: RESULT = new Type("unit"); :}
;

formals ::=
  formalList:fl formal:f           {: RESULT = new FormalList(fl, f); :}
| empty                            {: RESULT = new FormalList(); :}
;

formalList ::=
  formalList:fl formal:f COMMA     {: RESULT = new FormalList(fl, f); :}
| empty                            {: RESULT = new FormalList(); :}
;

formal ::=
  IDENTIFIER:id COLON type:ty      {: RESULT = new Formal(id.stringValue(), ty); :}
;

block ::=
  LBRACE exprList:el expr:e RBRACE           {: RESULT = new ExprList(el, e); :}
;

exprList ::=
  exprList:el expr:e SEMICOLON         {: RESULT = new ExprList(el, e); :}
| empty                                {: RESULT = new ExprList(); :}
;

expr ::=
  matched:m       {: RESULT = m; :}
| unmatched:u     {: RESULT = u; :}
;

matched ::=
  IF expr:e1 THEN matched:e2 ELSE matched:e3     {: RESULT = new If(e1, e2, e3) :}
| noIf:n                                         {: RESULT = n; :}
;

unmatched ::=
  IF expr:e1 THEN expr:e2                         {: RESULT = new If(e1, e2); :}
| IF expr:e1 THEN matched:e2 ELSE unmatched:e3    {: RESULT = new If(e1, e2, e3); :}
;

noIf ::=  //TODO check if while etc
  WHILE expr:e1 DO expr:e2                                      {: RESULT = new While(e1, e2); :}
| LET IDENTIFIER:id COLON type:ty IN expr:e                     {: RESULT = new Let(id.stringValue(), ty, e); :}
| LET IDENTIFIER:id COLON type:ty ASSIGN expr:e1 IN expr:e2     {: RESULT = new Let(id.stringValue(), ty, e1, e2); :}
| IDENTIFIER:id ASSIGN expr:e                                   {: RESULT = new Assign(id.stringValue(), e); :}
| NOT:kw expr:e                                                 {: RESULT = new UnOp(kw.getTokenType().getStringValue(), e); :}
| MINUS:kw expr:e                                               {: RESULT = new UnOp(kw.getTokenType().getStringValue(), e); :}
| ISNULL:kw expr:e                                              {: RESULT = new UnOp(kw.getTokenType().getStringValue(), e); :}
| expr:e1 AND:kw expr:e2                                        {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| expr:e1 EQUAL:kw expr:e2                                      {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| expr:e1 LOWER:kw expr:e2                                      {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| expr:e1 LOWER_EQUAL:kw expr:e2                                {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| expr:e1 PLUS:kw expr:e2                                       {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| expr:e1 MINUS:kw expr:e2                                      {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| expr:e1 TIMES:kw expr:e2                                      {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| expr:e1 DIV:kw expr:e2                                        {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| expr:e1 POW:kw expr:e2                                        {: RESULT = new BinOp(kw.getTokenType().getStringValue(), e1, e2); :}
| IDENTIFIER:id LPAR args:ar RPAR                               {: RESULT = new Call(new Literal("self"), id.stringValue(), ar); :}
| expr:e DOT IDENTIFIER:id LPAR args:ar RPAR                    {: RESULT = new Call(e, id.stringValue(), ar); :}
| NEW TYPE_IDENTIFIER:ti                                        {: RESULT = new New(ti.stringValue()); :}
| IDENTIFIER:id                                                 {: RESULT = new Id(id.stringValue()); :}
| literal:li                                                    {: RESULT = li; :}
| LPAR expr:e RPAR                                              {: RESULT = e; :}
| block:b                                                       {: RESULT = b; :}
;

args ::=
  argList:al expr:e      {: RESULT = new ArgList(al, e) :}
| empty                  {: RESULT = new ArgList(); :}
;

argList ::=
  argList:al expr:e COMMA       {: RESULT = new ArgList(al, e); :}
| empty                         {: RESULT = new ArgList(); :}
;

literal ::=
  INT_LITERAL:il         {: RESULT = new Literal(il.stringValue()); :}
| STRING_LITERAL:sl      {: RESULT = new Literal(sl.stringValue()); :}
| booleanLiteral:bl      {: RESULT = bl; :}
;

booleanLiteral ::=
  TRUE:bl       {: RESULT = new Literal(bl.getTokenType().getStringValue()); :}
| FALSE:bl      {: RESULT = new Literal(bl.getTokenType().getStringValue()); :}
;

empty ::= ;
